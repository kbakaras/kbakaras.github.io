---
layout: post
title:  "Fispa: Фильтрация, сортировка, пагинация"
date:   2019-10-03 12:00:00 +0300
tags: pagination
---

## Цель статьи

Когда впервые сталкиваешься с темой пагинации, она кажется гораздо проще, чем на самом деле является. Погрузившись в детали, оказывается, что существует несколько принципиально разных подходов к проблеме. И подходы эти отличаются не только реализацией, но и применимы в разных ситуациях. То есть, существует проблема выбора подходящего варианта в конкретной задаче, и тут нет (и не может быть) единственного решения на все случаи жизни.

Рассмотреть особенности пагинации, определить факторы, влияющие на выбор правильного подхода к пагинации – это и есть цель данной статьи. Хочу сразу оговориться, что в первую очередь я буду уделять внимание серверной части.

## Для чего нужна пагинация

Пагинация нужна в первую очередь UI-клиентам для частичного отображения больших наборов данных и навигации по этим наборам с помощью листания или скроллирования. *Листание и скроллирование* – это две основных разновидности такой навигации с точки зрения UX. От выбора одной из этих двух разновидностей зависят детали реализации в том числе и серверной части. В современных приложениях встречаются и такие разновидности, как бесконечная лента.

# Фильтрация rest-api

В rest-интерфейсе public-api в настоящее время реализован подход к фильтрации *по мотивам* TreeQL, но с достаточно существенными доработками. В основном, доработки связаны с желанием обеспечить совместимость со стандартом OpenAPI. Родившийся в результате подход планируется использовать и в будущих rest-интерфейсах, совместимых с OpenAPI.

## Формат задания фильтров

Фильтрация задаётся с помощью параметра URL-запроса `filter`. Значением этого параметра может быть массив строк (это означает, что он будет встречаться в URL несколько раз) следующего формата:

`имя_поля, литерал_операции[, литерал_значения]*; имя_поля, литерал_операции[, литерал_значения]*`

Квадратные скобки и звёздочка вокруг `литерала_значения` означают, что, в зависимости от операции, значений может быть указано несколько (или, наоборот, ни одного). Если возникнет необходимость использовать символы запятой или точки с запятой в литералах значений, они должны быть *экранированы* круглыми скобками, например:

```http
не понял вопроса(,) затрудняюсь ответить --> "не понял вопроса, затрудняюсь ответить"
```

Точка с запятой разделяет несколько условий фильтрации. В приведённом примере их только два, но может быть  от одного и более. Эта строка представляет один элемент массива фильтров, передаваемых в запросе. Если в рамках одного элемента имеется несколько условий фильтрации, они будут объединены конъюнкцией. Если в запросе передан массив фильтров, состоящий более чем из одной строки фильтрации, фильтры на основе элементов массива объединяются дизъюнкцией. Рассмотрим пример:

```http
filter=login,sw,Admin;name,is&filter=login,sw,User
```

На основе этого фильтра в результате трансляции будет построено следующее выражение для фильтрации:

```sql
(user.login LIKE 'Admin%' AND user.name IS NULL) OR (user.login LIKE 'User%')
```

Тут я использовал SQL-подобный синтаксис. Скобки в примере служат только для объединения групп конъюнкций с целью облегчить чтение, в реальной жизни они не являются обязательными.

### Поддерживаемые логические операции

В настоящее время поддерживается определённый набор логических операций. Соответственно, литерал операции может принимать одно из значений, перечисленных в таблице:

| Литерал операции | Описание                                                   |
| ---------------- | ---------------------------------------------------------- |
| cs               | contain string (string contains value)                     |
| sw               | start with (string starts with value)                      |
| ew               | end with (string end with value)                           |
| eq               | equal (string or number matches exactly)                   |
| lt               | lower than (number is lower than value)                    |
| le               | lower or equal (number is lower than or equal to value)    |
| ge               | greater or equal (number is higher than or equal to value) |
| gt               | greater than (number is higher than value)                 |
| bt               | between (number is between two comma separated values)     |
| in               | in (number or string is in comma separated list of values) |
| is               | is null (field contains “NULL” value)                      |

Кроме перечисленных в таблице также воспринимаются литералы с отрицанием. Для этого к одному из литералов нужно добавить префикс `n`.

### Примечания

Таким образом, имеется возможность накладывать практически любые условия фильтрации, выражая их в *Дизъюнктивной Нормальной Форме*.

Хочу заметить, что (в отличие от исходного синтаксиса URL-запроса) и в SwaggerUI, и в сгенерированном для Java коде объект `filter` будет массивом, и запутывающий восприятие эффект использования значка `&` для разделения дизъюнктируемых частей фильтра пропадёт.

## Формат задания сортировки

Сортировка, по аналогии с фильтрацией, задаётся с помощью параметра URL-запроса `order`, значением которого может быть массив строк:

```http
order=login&order=age,desc
```

Выражения сортировки устроены гораздо проще. В общем случае, одно выражение сортировки состоит из имени поля и направления сортировки, разделённых запятой. Направление сортировки задаётся строковыми литералами: `asc` и `desc`.

## Формат задания пагинации

Для задания пагинации сейчас существует три способа. В отдельном запросе можно воспользоваться только одним из вариантов. Попытка задать пагинацию двумя разными способами в одном запросе приведёт к выбрасыванию исключения. Все три варианта относятся к типу пагинации "по смещению". Вариант зависит от того, какой из трёх возможных параметров запроса будет задан:

| Имя параметра | Формат значения                   | Описание |
| ------------- | --------------------------------- | -------- |
| page          | `размер_страницы[,номер_страницы]` | Запрос указанной страницы. Учитывается квантование на страницы, применяется сатурация. |
| shift         | `размер_фрагмента[,смещение_фрагмента]` | Запрос фрагмента указанного размера с учётом смещения. Применяется сатурация. |
| size          | `размер_фрагмента[,смещение_фрагмента]` | Запрос фрагмента указанного размера и смещения. Сатурация не применяется. Если запрошен фрагмент, которого нет в источнике, будет возвращён результат с пустым списком. |

Во всех вариантах нумерация параметров начинается с 0.

Также, во всех вариантах по умолчанию включен контроль консистентности возвращаемого результата на стороне сервера. Это означает, что сервер следит за тем, чтобы мета-информация, возвращаемая в ответе, не противоречила размеру полученного списка элементов.

### Формат результата

Результат запроса помещается в тело ответа в формате JSON и содержит следующие поля:

| Имя поля   | Описание                                                     |
| ---------- | ------------------------------------------------------------ |
| list       | Результирующий список элементов                              |
| totalCount | Общее количество элементов в источнике с учётом заданной фильтрации |
| offset     | Результирующее смещение начала списка. Может отличаться от запрошенного, если использовалась сатурация. Поле offset вычисляется в любом случае, даже если применялся page-запрос. |
| page       | Результирующий индекс страницы возвращённого фрагмента. Может отличаться от запрошенного в результате сатурации. Если применялся не page-запрос, будет содержать `null`. |
| pageCount  | Общее количество страниц на момент запроса с учётом заданного размера страницы. Если применялся не page-запрос, будет содержать `null`. |
| filter     | Дословно повторяет массив фильтров, заданных в запросе.      |
| order      | Дословно повторяет массив сортировок заданных в запросе.     |

### Примечания

При использовании пагинации важно учитывать, что сортировка элементов, получаемых из источника, важна для согласованности результатов, получаемых последовательными запросами. Если источник данных не гарантирует воспроизводимости порядка элементов между запросами, для которых сортировка явно не задана, на ответственности клиента лежит задание минимальной сортировки. Рекомендую в случаях, когда пользователь не задаёт никаких полей для сортировки, использовать на клиенте неявно (для пользователя) сортировку по первичному ключу.