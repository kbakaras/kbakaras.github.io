---
layout: post
title:  "Fispa: Фильтрация, сортировка, пагинация"
date:   2019-10-03 12:00:00 +0300
tags: pagination
---

## Цель статьи

Когда впервые сталкиваешься с темой пагинации, она кажется гораздо проще, чем на самом деле является. Погрузившись в детали, оказывается, что существует несколько принципиально разных подходов к проблеме. И подходы эти отличаются не только реализацией, но и применимы в разных ситуациях. То есть, существует проблема выбора подходящего варианта в конкретной задаче, и тут нет (и не может быть) единственного решения на все случаи жизни.

Рассмотреть особенности пагинации, определить факторы, влияющие на выбор правильного подхода к пагинации – это и есть цель данной статьи. Хочу сразу оговориться, что в первую очередь я буду уделять внимание серверной части.

## Для чего нужна пагинация

Пагинация нужна в первую очередь UI-клиентам для частичного отображения больших наборов данных и навигации по этим наборам с помощью листания или скроллирования. *Листание и скроллирование* – это две основных разновидности такой навигации с точки зрения UX. От выбора одной из этих двух разновидностей зависят детали реализации в том числе и серверной части. В современных приложениях встречаются и такие разновидности, как бесконечная лента.

## Виды пагинации

Мне известно о двух способах организации пагинации: основанном на смещении (offset-пагинация) и keyset-пагинация. Я в своей практике (в основном, enterprise-приложения) сталкивался с пагинацией, основанной на смещении. Она подходит для организации скроллинга и пролистывания наборов данных, которые относительно стабильны.

Keyset-пагинация используется в *бесконечных лентах* современных WEB-приложений. Например, в ленте новостей, особенно, если новости постоянно пополняются свежими, пагинация по смещению приведёт к проявлению странных эффектов в интерфейсе и будет запутывать пользователя. Keyset-пагинация хорошо описана в серии статей [Faster SQL Pagination with jOOQ Using the Seek Method](https://blog.jooq.org/2013/10/26/faster-sql-paging-with-jooq-using-the-seek-method/). Я же буду больше касаться offset-пагинации.

Вообще, предпочтение одного вида пагинации другому определяется феноменами, которые могут проявляться в процессе работы пользователя с GUI. А также компромиссным выбором для данного конкретного случая того, какие из феноменов категорически не допустимы, а какие можно терпеть. Возникновение любых феноменов связано с параллельным изменение данных в источнике (добавлением новых данных, удалением данных).

Например, при offset-пагинации добавление данных перед текущим окном выборки приведёт к тому, что пролистывание на следующую страницу может вернуть часть новых данных и часть старых, которые были видны до этого пролистывания. Удаление же данных может привести к не очевидному для пользователя "перескакиванию" некоторых элементов при пролистывании на следующую страницу.

В корпоративных приложениях, как правило, большая часть источников данных относительно стабильна, либо прирастает с конца выборок. Поэтому для них offset-пагинация является наиболее адекватной. Ещё одним плюсом является то, что offset-пагинация позволяет делать решения общего вида, которые можно единообразно применять к разным наборам данных системы. Это важно, так как в корпоративных информационных системах обычно большое количество сущностей.

В приложениях типа новостных лент (Facebook, Twitter), напротив, наиболее свежие данные поступают в начало выборок. В этом случае применяют keyset-пагинацию. Если кратко, её особенностью является работа не со смещением, а с некоторым ключевым элементом, относительно которого происходит пролистывание вперёд, либо назад. В такого типа приложениях важно оградить пользователя от повторного вывода элементов после пролистывания, а также от перескакивания (возможно важных) для него элементов. Ограничениями этого подхода будут:

* невозможность оценить объём данных в источнике и текущее относительное положение внутри этого объёма;
* возможности навигации будут ограничены: либо только прокручиванием бесконечной ленты, либо ограниченным переходом на несколько (а часто, лишь на одну) страниц вперёд или назад.

## Фильтрация rest-api

В rest-интерфейсе public-api в настоящее время реализован подход к фильтрации *по мотивам* [TreeQL](https://treeql.org/learn/), но с достаточно существенными доработками. В основном, доработки связаны с желанием обеспечить совместимость со стандартом OpenAPI. Родившийся в результате подход планируется использовать и в будущих rest-интерфейсах, совместимых с OpenAPI.

## Формат задания фильтров

Фильтрация задаётся с помощью параметра URL-запроса `filter`. Значением этого параметра может быть массив строк (это означает, что он будет встречаться в URL несколько раз) следующего формата:

`имя_поля, литерал_операции[, литерал_значения]*; имя_поля, литерал_операции[, литерал_значения]*`

Квадратные скобки и звёздочка вокруг `литерала_значения` означают, что, в зависимости от операции, значений может быть указано несколько (или, наоборот, ни одного). Если возникнет необходимость использовать символы запятой или точки с запятой в литералах значений, они должны быть *экранированы* круглыми скобками, например:

```http
не понял вопроса(,) затрудняюсь ответить --> "не понял вопроса, затрудняюсь ответить"
```

Точка с запятой разделяет несколько условий фильтрации. В приведённом примере их только два, но может быть  от одного и более. Эта строка представляет один элемент массива фильтров, передаваемых в запросе. Если в рамках одного элемента имеется несколько условий фильтрации, они будут объединены конъюнкцией. Если в запросе передан массив фильтров, состоящий более чем из одной строки фильтрации, фильтры на основе элементов массива объединяются дизъюнкцией. Рассмотрим пример:

```http
filter=login,sw,Admin;name,is&filter=login,sw,User
```

На основе этого фильтра в результате трансляции будет построено следующее выражение для фильтрации:

```sql
(user.login LIKE 'Admin%' AND user.name IS NULL) OR (user.login LIKE 'User%')
```

Тут я использовал SQL-подобный синтаксис. Скобки в примере служат только для объединения групп конъюнкций с целью облегчить чтение, в реальной жизни они не являются обязательными.

### Поддерживаемые логические операции

В настоящее время поддерживается определённый набор логических операций. Соответственно, литерал операции может принимать одно из значений, перечисленных в таблице:

| Литерал операции | Описание                                                   |
| ---------------- | ---------------------------------------------------------- |
| cs               | contain string (string contains value)                     |
| sw               | start with (string starts with value)                      |
| ew               | end with (string end with value)                           |
| eq               | equal (string or number matches exactly)                   |
| lt               | lower than (number is lower than value)                    |
| le               | lower or equal (number is lower than or equal to value)    |
| ge               | greater or equal (number is higher than or equal to value) |
| gt               | greater than (number is higher than value)                 |
| bt               | between (number is between two comma separated values)     |
| in               | in (number or string is in comma separated list of values) |
| is               | is null (field contains “NULL” value)                      |

Кроме перечисленных в таблице также воспринимаются литералы с отрицанием. Для этого к одному из литералов нужно добавить префикс `n`.

### Примечания

Таким образом, имеется возможность накладывать практически любые условия фильтрации, выражая их в *Дизъюнктивной Нормальной Форме*.

Хочу заметить, что (в отличие от исходного синтаксиса URL-запроса) и в SwaggerUI, и в сгенерированном для Java коде объект `filter` будет массивом, и запутывающий восприятие эффект использования значка `&` для разделения дизъюнктируемых частей фильтра пропадёт.

## Формат задания сортировки

Сортировка, по аналогии с фильтрацией, задаётся с помощью параметра URL-запроса `order`, значением которого может быть массив строк:

```http
order=login&order=age,desc
```

Выражения сортировки устроены гораздо проще. В общем случае, одно выражение сортировки состоит из имени поля и направления сортировки, разделённых запятой. Направление сортировки задаётся строковыми литералами: `asc` и `desc`.

## Формат задания пагинации

Для задания пагинации сейчас существует три способа. В отдельном запросе можно воспользоваться только одним из вариантов. Попытка задать пагинацию двумя разными способами в одном запросе приведёт к выбрасыванию исключения. Все три варианта относятся к типу пагинации "по смещению". Вариант зависит от того, какой из трёх возможных параметров запроса будет задан:

| Имя параметра | Формат значения                   | Описание |
| ------------- | --------------------------------- | -------- |
| page          | `размер_страницы[,номер_страницы]` | Запрос указанной страницы. Учитывается квантование на страницы, применяется сатурация. |
| shift         | `размер_фрагмента[,смещение_фрагмента]` | Запрос фрагмента указанного размера с учётом смещения. Применяется сатурация. |
| size          | `размер_фрагмента[,смещение_фрагмента]` | Запрос фрагмента указанного размера и смещения. Сатурация не применяется. Если запрошен фрагмент, которого нет в источнике, будет возвращён результат с пустым списком. |

Во всех вариантах нумерация параметров начинается с 0.

Также, во всех вариантах по умолчанию включен контроль консистентности возвращаемого результата на стороне сервера. Это означает, что сервер следит за тем, чтобы мета-информация, возвращаемая в ответе, не противоречила размеру полученного списка элементов.

### Формат результата

Результат запроса помещается в тело ответа в формате JSON и содержит следующие поля:

| Имя поля   | Описание                                                     |
| ---------- | ------------------------------------------------------------ |
| list       | Результирующий список элементов                              |
| totalCount | Общее количество элементов в источнике с учётом заданной фильтрации |
| offset     | Результирующее смещение начала списка. Может отличаться от запрошенного, если использовалась сатурация. Поле offset вычисляется в любом случае, даже если применялся page-запрос. |
| page       | Результирующий индекс страницы возвращённого фрагмента. Может отличаться от запрошенного в результате сатурации. Если применялся не page-запрос, будет содержать `null`. |
| pageCount  | Общее количество страниц на момент запроса с учётом заданного размера страницы. Если применялся не page-запрос, будет содержать `null`. |
| filter     | Дословно повторяет массив фильтров, заданных в запросе.      |
| order      | Дословно повторяет массив сортировок заданных в запросе.     |

### Примечания

При использовании пагинации важно учитывать, что сортировка элементов, получаемых из источника, важна для согласованности результатов, получаемых последовательными запросами. Если источник данных не гарантирует воспроизводимости порядка элементов между запросами, для которых сортировка явно не задана, на ответственности клиента лежит задание минимальной сортировки. Рекомендую в случаях, когда пользователь не задаёт никаких полей для сортировки, использовать на клиенте неявно (для пользователя) сортировку по первичному ключу.

## Полезные ссылки

1. [TreeQL: REST-API к SQL базам данных](https://treeql.org/).
2. [Why Most Programmers Get Pagination Wrong](https://blog.jooq.org/2016/08/10/why-most-programmers-get-pagination-wrong/).
3. [Faster SQL Pagination with jOOQ Using the Seek Method](https://blog.jooq.org/2013/10/26/faster-sql-paging-with-jooq-using-the-seek-method/).
4. [Faster SQL Pagination with Keysets, Continued](https://blog.jooq.org/2013/11/18/faster-sql-pagination-with-keysets-continued/).